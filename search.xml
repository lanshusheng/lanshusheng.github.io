<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>为什么会写博客</title>
    <url>/2020/07/28/remind/</url>
    <content><![CDATA[<h4 id="不忘初心？"><a href="#不忘初心？" class="headerlink" title="不忘初心？"></a>不忘初心？</h4><h3 id="价值？"><a href="#价值？" class="headerlink" title="价值？"></a>价值？</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ create table me</span><br></pre></td></tr></table></figure>


<blockquote>
<blockquote>
<blockquote>
<p>我有一头小毛驴，偶尔骑一骑。<br></p>
</blockquote>
</blockquote>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>计数器</title>
    <url>/2020/07/31/%E8%AE%A1%E6%95%B0%E5%99%A8/</url>
    <content><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><h3 id="为什么要引入计数器"><a href="#为什么要引入计数器" class="headerlink" title="为什么要引入计数器"></a>为什么要引入计数器</h3><p>计数器的作用如下：</p>
<p>   1、简单的好处是：可以加速读取的时间。</p>
<p>   2、对于大量（80%）帖子，其实都没有任何数（评论，点赞）。对于计数器，内部为0的数据，可以减少很多timeline的读取操作。</p>
<a id="more"></a>

<h1 id="一、需求背景。"><a href="#一、需求背景。" class="headerlink" title="一、需求背景。"></a>一、需求背景。</h1><p>现在计数场景越来越多，而我们当前读取的方式主要是两种。</p>
<ol>
<li>​    数目（转发数，收藏数等）直接写库。更新方式： update set count = count + 1 where id = ?</li>
<li>​    数目（点赞数）直接读取timeline : 读取方式为 select  count(<em>) from **</em> ;为什么不使用zcard读取list size，这是因为timeline是会过期的，并且很容易过期。为了计数加载全量缓存的方式很不明智。</li>
</ol>
<p>两种方式分别有什么问题？</p>
<p>​    第一种方案，在高并发场景下，存在锁等待超时的问题。大概可以参考：<a href="https://blog.csdn.net/miyatang/article/details/82454999" target="_blank" rel="noopener">https://blog.csdn.net/miyatang/article/details/82454999</a></p>
<p>​    第二种方案，随着表数据越来越多。查询时间会越来越长，效率越来越低，并且，如果伴随着数据增多的情况下，一次query的耗时很容易20ms+；</p>
<h1 id="二、需求场景"><a href="#二、需求场景" class="headerlink" title="二、需求场景"></a>二、需求场景</h1><p>​    回头来看，我们需要这些数据都有哪些场景。</p>
<ol>
<li><p>读多写少或者说更新少。</p>
</li>
<li><p>更新频繁。如：阅读数、本场景的音频播放数。</p>
</li>
<li><p>希望的请求结果是：以获取一个feed（帖子）来举例。当db缓存失效的时候。我期待的最优结果应该是：</p>
<ol>
<li><p>我读取一次db，拿到全部的值（点赞数，阅读数等）</p>
</li>
<li><p>我期待的次优结果应该是：我读一次db拿到大部分的值，剩下的值，通过读redis来获取。</p>
<p>现状是：我读一次db，只能拿到部分值（评论数，转发数）。剩下的数（点赞数），需要通过count(*)的方式来获取。耗时较长。</p>
</li>
</ol>
</li>
</ol>
<h1 id="三、计数器的方案预想"><a href="#三、计数器的方案预想" class="headerlink" title="三、计数器的方案预想"></a>三、计数器的方案预想</h1><p>​     从上面的分析而言，我们需要的方案有哪一些。</p>
<ol>
<li>最好的方案：我期待读库能拿到全部的值。但是dau上涨之后，通过 update set count = count + 1 where id = ? 这种方案可能会有锁等待超时的问题。</li>
<li>次优的方案，我能通过读一次db拿到大部分的结果，剩下的都读cache拿到剩下的数。</li>
<li>强一致性的方案：如评论数，我评论完了，肯定希望立刻看到评论数+1.</li>
<li>弱一致性的方案：如音频播放数：我隔一会看到变化都没关系。</li>
</ol>
<h1 id="四、方案设计"><a href="#四、方案设计" class="headerlink" title="四、方案设计"></a>四、方案设计</h1><p>​    针对上面的四种场景，对应的设计方案主要是两种。</p>
<h2 id="1、单开计数器"><a href="#1、单开计数器" class="headerlink" title="1、单开计数器"></a>1、单开计数器</h2><p>​                像点赞数：使用redis.incr 操作，查询时间复杂度o(1)。 可以满足现在的次优方案、且强一致性的方案。</p>
<p>​                 缺点：读取相对比较麻烦。数据同步比较麻烦（数据统计也有一定问题）。</p>
<h2 id="2、优化处理写库的问题。"><a href="#2、优化处理写库的问题。" class="headerlink" title="2、优化处理写库的问题。"></a>2、优化处理写库的问题。</h2><p>​                demo：基于计数器和时间片的方案：优化 update count = count + 1   → 转化为： update count = count + N;</p>
<p>​            一方面可以削峰，处理高并发带来的锁等待超时的问题。另一个方面可以满足最终一致性的问题。</p>
<p>​         eg： 以N = 10 为例。当播放数count 等数据，每次count % 10 ==0 的时候   或者 时间片耗尽的时候，我们才去更新库。这个时候也可以保证最终一致性。</p>
<h1 id="五、方案补充"><a href="#五、方案补充" class="headerlink" title="五、方案补充"></a>五、方案补充</h1><ol>
<li>​     离线数据怎么存储？kafka → hdfs</li>
<li>​     热数据怎么来</li>
</ol>
<script src="https://utteranc.es/client.js" repo="lanshusheng/lanshusheng.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async>
</script>

]]></content>
      <categories>
        <category>计数器</category>
      </categories>
      <tags>
        <tag>计数器</tag>
        <tag>feed流</tag>
      </tags>
  </entry>
  <entry>
    <title>关于计数器的一些思考</title>
    <url>/2020/07/30/%E5%85%B3%E4%BA%8E%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>#概览</p>
<a id="more"></a>

<h3 id="为什么要引入计数器"><a href="#为什么要引入计数器" class="headerlink" title="为什么要引入计数器"></a>为什么要引入计数器</h3><p>计数器的作用如下：</p>
<script src="https://utteranc.es/client.js" repo="lanshusheng/lanshusheng.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async>
</script>]]></content>
      <categories>
        <category>计数器</category>
      </categories>
      <tags>
        <tag>计数器</tag>
        <tag>feed流</tag>
      </tags>
  </entry>
  <entry>
    <title>Young gc 频繁的解决方案</title>
    <url>/2020/07/28/gc/</url>
    <content><![CDATA[<p>gc效果优化如图：</p>
<p><img src="/2020/07/28/gc/94CBD6BE-9426-4287-A38F-024F68D6DD6D.png" alt="94CBD6BE-9426-4287-A38F-024F68D6DD6D"></p>
<p>原理以及调优过程：</p>
<a id="more"></a>



<h1 id="一、young-gc的耗时统计二、常见垃圾回收器GC日志参数基本策略三、优化步骤优化四、现状确定目标优化"><a href="#一、young-gc的耗时统计二、常见垃圾回收器GC日志参数基本策略三、优化步骤优化四、现状确定目标优化" class="headerlink" title="一、young gc的耗时统计二、常见垃圾回收器GC日志参数基本策略三、优化步骤优化四、现状确定目标优化"></a><a href="https://docs.snowballfinance.com/pages/viewpage.action?pageId=75464817#id-频繁的younggc给系统带来的负担-一、younggc的耗时统计" target="_blank" rel="noopener">一、young gc的耗时统计</a><a href="https://docs.snowballfinance.com/pages/viewpage.action?pageId=75464817#id-频繁的younggc给系统带来的负担-二、常见垃圾回收器" target="_blank" rel="noopener">二、常见垃圾回收器</a><a href="https://docs.snowballfinance.com/pages/viewpage.action?pageId=75464817#id-频繁的younggc给系统带来的负担-GC日志" target="_blank" rel="noopener">GC日志</a><a href="https://docs.snowballfinance.com/pages/viewpage.action?pageId=75464817#id-频繁的younggc给系统带来的负担-参数基本策略" target="_blank" rel="noopener">参数基本策略</a><a href="https://docs.snowballfinance.com/pages/viewpage.action?pageId=75464817#id-频繁的younggc给系统带来的负担-三、优化步骤" target="_blank" rel="noopener">三、优化步骤</a><a href="https://docs.snowballfinance.com/pages/viewpage.action?pageId=75464817#id-频繁的younggc给系统带来的负担-优化" target="_blank" rel="noopener">优化</a><a href="https://docs.snowballfinance.com/pages/viewpage.action?pageId=75464817#id-频繁的younggc给系统带来的负担-四、现状" target="_blank" rel="noopener">四、现状</a><a href="https://docs.snowballfinance.com/pages/viewpage.action?pageId=75464817#id-频繁的younggc给系统带来的负担-确定目标" target="_blank" rel="noopener">确定目标</a><a href="https://docs.snowballfinance.com/pages/viewpage.action?pageId=75464817#id-频繁的younggc给系统带来的负担-优化.1" target="_blank" rel="noopener">优化</a></h1><h1 id="一、young-gc的耗时统计"><a href="#一、young-gc的耗时统计" class="headerlink" title="一、young gc的耗时统计"></a>一、young gc的耗时统计</h1><ul>
<li>目前的young gc耗时以及次数如下：</li>
</ul>
<p><img src="https://docs.snowballfinance.com/download/attachments/75464817/image2020-7-21_10-57-33.png?version=1&modificationDate=1595300253000&api=v2" alt="img"></p>
<p><img src="https://docs.snowballfinance.com/download/attachments/75464817/image2020-7-21_11-0-10.png?version=1&modificationDate=1595300411000&api=v2" alt="img"></p>
<ul>
<li>young gc的耗时较长，吞吐量较低。核心是解决耗时的问题。YoungGC 的耗时在 200ms 以上，几乎没有什么对象晋升，频率 4-5 秒一次。GC 日志截图如下。</li>
</ul>
<p><img src="https://docs.snowballfinance.com/download/attachments/75464817/image2020-7-21_11-12-21.png?version=1&modificationDate=1595301141000&api=v2" alt="img"></p>
<ul>
<li>gc的配置如下：</li>
</ul>
<h1 id="二、常见垃圾回收器"><a href="#二、常见垃圾回收器" class="headerlink" title="二、常见垃圾回收器"></a>二、常见垃圾回收器</h1><p>不同的垃圾回收器，适用于不同的场景。常用的垃圾回收器：</p>
<ul>
<li>串行（Serial）回收器是单线程的一个回收器，简单、易实现、效率高。</li>
<li>并行（ParNew）回收器是Serial的多线程版，可以充分的利用CPU资源，减少回收的时间。</li>
<li>吞吐量优先（Parallel Scavenge）回收器，侧重于吞吐量的控制。</li>
<li>并发标记清除（CMS，Concurrent Mark Sweep）回收器是一种以获取最短回收停顿时间为目标的回收器，该回收器是基于“标记-清除”算法实现的。</li>
</ul>
<h4 id="GC日志"><a href="#GC日志" class="headerlink" title="GC日志"></a>GC日志</h4><p>每一种回收器的日志格式都是由其自身的实现决定的，换而言之，每种回收器的日志格式都可以不一样。但虚拟机设计者为了方便用户阅读，将各个回收器的日志都维持一定的共性。</p>
<h3 id="参数基本策略"><a href="#参数基本策略" class="headerlink" title="参数基本策略"></a>参数基本策略</h3><p>各分区的大小对GC的性能影响很大。如何将各分区调整到合适的大小，分析活跃数据的大小是很好的切入点。</p>
<p>活跃数据的大小是指，应用程序稳定运行时长期存活对象在堆中占用的空间大小，也就是Full GC后堆中老年代占用空间的大小。可以通过GC日志中Full GC之后老年代数据大小得出，比较准确的方法是在程序稳定后，多次获取GC数据，通过取平均值的方式计算活跃数据的大小。活跃数据和各分区之间的比例关系如下：</p>
<table>
<thead>
<tr>
<th align="left">空间</th>
<th align="left">倍数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">总大小</td>
<td align="left">3-4 倍活跃数据的大小</td>
</tr>
<tr>
<td align="left">新生代</td>
<td align="left">1-1.5 活跃数据的大小</td>
</tr>
<tr>
<td align="left">老年代</td>
<td align="left">2-3 倍活跃数据的大小</td>
</tr>
<tr>
<td align="left">永久代</td>
<td align="left">1.2-1.5 倍Full GC后的永久代空间占用</td>
</tr>
</tbody></table>
<p>例如，根据GC日志获得老年代的活跃数据大小为300M，那么各分区大小可以设为：</p>
<blockquote>
<p>总堆：1200MB = 300MB × 4* 新生代：450MB = 300MB × 1.5* 老年代： 750MB = 1200MB - 450MB*</p>
</blockquote>
<p>这部分设置仅仅是堆大小的初始值，后面的优化中，可能会调整这些值，具体情况取决于应用程序的特性和需求。</p>
<p><img src="https://docs.snowballfinance.com/download/attachments/75464817/image2020-7-21_19-54-38.png?version=1&modificationDate=1595332481000&api=v2" alt="img"></p>
<h1 id="三、优化步骤"><a href="#三、优化步骤" class="headerlink" title="三、优化步骤"></a>三、优化步骤</h1><p>GC优化一般步骤可以概括为：确定目标、优化参数、验收结果。</p>
<p>举例：假设单位时间T内发生一次持续25ms的GC，接口平均响应时间为50ms，且请求均匀到达，根据下图所示：</p>
<p><img src="https://docs.snowballfinance.com/download/attachments/75464817/image2020-7-21_19-59-54.png?version=1&modificationDate=1595332797000&api=v2" alt="img"></p>
<p>那么有(50ms+25ms)/T比例的请求会受GC影响，其中GC前的50ms内到达的请求都会增加25ms，GC期间的25ms内到达的请求，会增加0-25ms不等，如果时间T内发生N次GC，受GC影响请求占比=(接口响应时间+GC时间)×N/T 。可见无论降低单次GC时间还是降低GC次数N都可以有效减少GC对响应时间的影响。</p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>通过收集GC信息，结合系统需求，确定优化方案，例如选用合适的GC回收器、重新设置内存比例、调整JVM参数等。</p>
<p>进行调整后，将不同的优化方案分别应用到多台机器上，然后比较这些机器上GC的性能差异，有针对性的做出选择，再通过不断的试验和观察，找到最合适的参数。</p>
<h1 id="四、现状"><a href="#四、现状" class="headerlink" title="四、现状"></a>四、现状</h1><h2 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h2><p>服务情况：young gc 每分钟25次，每次大概200ms。接口响应时间大概平均为400ms 。<em>（200ms+400ms）× 25次/60000ms = 25% 请求时间会增加。</em></p>
<p><strong>优化目标</strong>：降低P99时间。</p>
<h2 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h2><p>首先优化Minor GC频繁问题。通常情况下，由于新生代空间较小，Eden区很快被填满，就会导致频繁Minor GC，因此可以通过增大新生代空间来降低Minor GC的频率。例如在相同的内存分配率的前提下，新生代中的Eden区增加一倍，Minor GC的次数就会减少一半。</p>
<p>这时很多人有这样的疑问，扩容Eden区虽然可以减少Minor GC的次数，但会增加单次Minor GC时间么？根据上面公式，如果单次Minor GC时间也增加，很难保证最后的优化效果。我们结合下面情况来分析，单次Minor GC时间主要受哪些因素影响？是否和新生代大小存在线性关系？ 首先，单次Minor GC时间由以下两部分组成：T1（扫描新生代）和 T2（复制存活对象到Survivor区）如下图。（注：这里为了简化问题，我们认为T1只扫描新生代判断对象是否存活的时间，其实该阶段还需要扫描部分老年代，后面案例中有详细描述。）</p>
<p><img src="https://docs.snowballfinance.com/download/attachments/75464817/image2020-7-21_20-46-48.png?version=1&modificationDate=1595335611000&api=v2" alt="img"></p>
<ul>
<li>扩容前：新生代容量为R ，假设对象A的存活时间为750ms，Minor GC间隔500ms，那么本次Minor GC时间= T1（扫描新生代R）+T2（复制对象A到S）。</li>
<li>扩容后：新生代容量为2R ，对象A的生命周期为750ms，那么Minor GC间隔增加为1000ms，此时Minor GC对象A已不再存活，不需要把它复制到Survivor区，那么本次GC时间 = 2 × T1（扫描新生代R），没有T2复制时间。</li>
</ul>
<p>可见，扩容后，Minor GC时增加了T1（扫描时间），但省去T2（复制对象）的时间，更重要的是对于虚拟机来说，复制对象的成本要远高于扫描成本，所以，单次Minor GC时间更多取决于GC后存活对象的数量，而非Eden区的大小。因此如果堆中短期对象很多，那么扩容新生代，单次Minor GC时间不会显著增加。下面需要确认下服务中对象的生命周期分布情况：</p>
<p><img src="https://docs.snowballfinance.com/download/attachments/75464817/image2020-7-21_20-47-10.png?version=1&modificationDate=1595335633000&api=v2" alt="img"></p>
<p>这是典型G1的Evacuation Pause(转移暂停)，在这个阶段存活的对象被从一个分区（年轻代或年轻代+老年代）拷贝到另一个分区。</p>
<p>这是一个STW，所有的应用线程停止在安全点。</p>
<p><img src="https://docs.snowballfinance.com/download/attachments/75464817/image2020-7-22_13-55-33.png?version=1&modificationDate=1595397334000&api=v2" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.522: [GC pause (young), 0.15877971 secs]</span><br></pre></td></tr></table></figure>

<p>​    这是一个转移暂停，距离进程启动的0.522秒开始，所有被转移的是年轻代分区，一共花费了0.15877971秒。</p>
<p>​    转移暂停也可以是混合的，比如：1.730:[GC pause (mixed), 0.32714353 secs]<strong>，</strong>此时分区包含所有的年轻代分区和部分老年代分区。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  [Parallel Time: 157.1 ms]</span><br><span class="line">  并行GC Worker线程的总耗时，下面缩进部分是worker线程的子任务</span><br><span class="line">     [GC Worker Start (ms):  522.1  522.2  522.2  522.2 </span><br><span class="line">每个worker线程的启动时间（距离jvm启动的时间）</span><br><span class="line">      Avg: 522.2, Min: 522.1, Max: 522.2, Diff:   0.1] </span><br><span class="line">所有线程启动时间的avg,min,max,diff(下同，不赘述)</span><br><span class="line">     [Ext Root Scanning (ms):  1.6  1.5  1.6  1.9 </span><br><span class="line">每个线程扫描Roots（全局变量，寄存器，线程栈，vm数据结构）的时间</span><br><span class="line">      Avg:   1.7, Min:   1.5, Max:   1.9, Diff:   0.4] 同上</span><br><span class="line">     [Update RS (ms):  38.7  38.8  50.6  37.3 </span><br><span class="line">每个线程更新Remember Set（RSet）时间，RSet保存引用</span><br><span class="line">      Avg:  41.3, Min:  37.3, Max:  50.6, Diff:  13.3]</span><br><span class="line">        [Processed Buffers : 2 2 3 2</span><br><span class="line">         Sum: 9, Avg: 2, Min: 2, Max: 3, Diff: 1]</span><br><span class="line">     [Scan RS (ms):  9.9  9.7  0.0  9.7 </span><br><span class="line">扫描RSet的时间，每个分区的RSet包含指向分区的Card。这个阶段扫描CSet集合中所有指向分区的Card。</span><br><span class="line">      Avg:   7.3, Min:   0.0, Max:   9.9, Diff:   9.9]</span><br><span class="line">     [Object Copy (ms):  106.7  106.8  104.6  107.9 </span><br><span class="line">拷贝CSet集合里面所有分区存活对象到另一个分区的时间。</span><br><span class="line">      Avg: 106.5, Min: 104.6, Max: 107.9, Diff:   3.3]</span><br><span class="line">     [Termination (ms):  0.0  0.0  0.0  0.0</span><br><span class="line">      Avg:   0.0, Min:   0.0, Max:   0.0, Diff:   0.0]</span><br><span class="line">        [Termination Attempts : 1 4 4 6</span><br><span class="line">         Sum: 15, Avg: 3, Min: 1, Max: 6, Diff: 5]</span><br><span class="line">     [GC Worker End (ms):  679.1  679.1  679.1  679.1 </span><br><span class="line">每个线程的停止时间</span><br><span class="line">      Avg: 679.1, Min: 679.1, Max: 679.1, Diff:   0.1]</span><br><span class="line">     [GC Worker (ms):  156.9  157.0  156.9  156.9 </span><br><span class="line">每个线程的耗时</span><br><span class="line">      Avg: 156.9, Min: 156.9, Max: 157.0, Diff:   0.1]</span><br><span class="line">     [GC Worker Other (ms):  0.3  0.3  0.3  0.3 </span><br><span class="line">每个线程执行除了上面操作的其他任务的耗时</span><br><span class="line">      Avg:   0.3, Min:   0.3, Max:   0.3, Diff:   0.0]</span><br><span class="line">  [Clear CT:   0.1 ms] </span><br><span class="line">串行清除Card Table的时间</span><br><span class="line">  [Other:   1.5 ms]</span><br><span class="line">     [Choose CSet:   0.0 ms] 为CSet选择Region的时间</span><br><span class="line">     [Ref Proc:   0.3 ms] 处理对象引用的时间</span><br><span class="line">     [Ref Enq:   0.0 ms] 引用入ReferenceQueues队列的时间</span><br><span class="line">     [Free CSet:   0.3 ms] 释放CSet时间</span><br><span class="line">  [Eden: 12M(12M)-&gt;0B(10M) Survivors: 0B-&gt;2048K Heap: 13M(64M)-&gt;9739K(64M)]</span><br><span class="line">  Eden在回收之前容量和占用都是12MB，回收之后占用为0，容量为13MB（有新的分区加入Eden）。</span><br><span class="line">Survivor回收之后，占用从0变到2048KB，整个堆在回收之前占用和容量是14MB和64MB，回收之后是9739KB和64MB。</span><br><span class="line">[Times: user&#x3D;0.59 sys&#x3D;0.02, real&#x3D;0.16 secs]</span><br></pre></td></tr></table></figure>





<p>S0C S1C S0U S1U EC EU OC OU MC MU CCSC CCSU YGC YGCT FGC FGCT GCT<br>0.0 106496.0 0.0 106496.0 2043904.0 1048576.0 6238208.0 2202526.5 188880.0 176103.4 23036.0 20985.0 32734 1590.882 0 0.000 1590.882</p>
<p><img src="https://docs.snowballfinance.com/download/attachments/75464817/image2020-7-22_20-40-28.png?version=1&modificationDate=1595421628000&api=v2" alt="img"></p>
<p>当前参数如下：可以看出：</p>
<ul>
<li><p>MC设计不合理：元数据空间十倍于使用大小</p>
</li>
<li><p>OC 老年</p>
</li>
<li><p><a href="http://zhongmingmao.me/2019/01/08/jvm-advanced-command/" target="_blank" rel="noopener">http://zhongmingmao.me/2019/01/08/jvm-advanced-command/</a> S0C 永远为0</p>
</li>
<li><p>S0C和S0U始终为0，这是因为使用G1 GC时，JVM不再设置Eden区、Survivor区和Old区的内存边界，而是将堆划分为若干个等长内存区域</p>
</li>
<li><p>每个内存区域都可以作为Eden区、Survivor区和Old区，并且可以在不同区域类型之间来回切换</p>
</li>
<li><p>因此，逻辑上只有一个Survivor区，当需要迁移Survivor区中的数据（Copying），只需要申请一个或多个内存区域，作为新的Survivor区</p>
</li>
<li><p>当发生垃圾回收时，JVM可能出现Survivor内存区域内的对象</p>
<p>全被回收</p>
<p>或者</p>
<p>全被晋升</p>
<p>的现象</p>
<ul>
<li>此时，JVM会将这块内存区域回收，并标记为可分配</li>
<li>结果堆中可能完全没有Survivor内存区域，S1C和S1U均为0</li>
</ul>
</li>
</ul>
<p><img src="https://docs.snowballfinance.com/download/thumbnails/75464817/image2020-7-22_20-48-34.png?version=1&modificationDate=1595422115000&api=v2" alt="img"></p>
<p><img src="https://docs.snowballfinance.com/download/attachments/75464817/image2020-7-22_21-23-54.png?version=1&modificationDate=1595424234000&api=v2" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;回收器的选择：https:&#96;&#96;&#x2F;&#x2F;blog&#96;&#96;.csdn.net&#96;&#96;&#x2F;lxlmycsdnfree&#x2F;article&#x2F;details&#x2F;81531363&#96; &#96;CMS回收器的好处&#96;&#96;-XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction&#x3D;0 -XX:CMSInitiatingOccupancyFraction&#x3D;70 -XX:+UseCMSInitiatingOccupancyOnly&#96;</span><br></pre></td></tr></table></figure>

<p>JDK 8开始把类的元数据放到本地化的堆内存(native heap)中，这一块区域就叫Metaspace，中文名叫元空间。<br>使用本地化的内存有什么好处呢？最直接的表现就是java.lang.OutOfMemoryError: PermGen 空间问题将不复存在，因为默认的类的元数据分配只受本地内存大小的限制，也就是说本地内存剩余多少，理论上Metaspace就可以有多大（貌似容量还与操作系统的虚拟内存有关？这里不太清楚），这解决了空间不足的问题。不过，让Metaspace变得无限大显然是不现实的，因此也要限制Metaspace的大小：</p>
<p>使用-XX:MaxMetaspaceSize参数来指定Metaspace区域的大小。</p>
<p>JVM默认在运行时根据需要动态地设置MaxMetaspaceSize的大小</p>
<p>关于元空间的一些误区：<a href="https://www.jianshu.com/p/b448c21d2e71。不是说配置了-XX:MetaspaceSize=50m" target="_blank" rel="noopener">https://www.jianshu.com/p/b448c21d2e71。不是说配置了-XX:MetaspaceSize=50m</a> -XX:MaxMetaspaceSize=256m 这个参数他的设置就会使你的metaspace区使用量达到这个值。</p>
<script src="https://utteranc.es/client.js" repo="lanshusheng/lanshusheng.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async>
</script>

]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>gc</tag>
        <tag>jvm 调优</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/07/28/hello-world/</url>
    <content><![CDATA[<h3 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h3><a id="more"></a>



<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<script src="https://utteranc.es/client.js" repo="lanshusheng/lanshusheng.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async>
</script>]]></content>
  </entry>
  <entry>
    <title>关于强弱软虚引用</title>
    <url>/2020/08/04/%E5%85%B3%E4%BA%8E%E5%BC%BA%E5%BC%B1%E8%99%9A%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>#【转】Java的引用核心</p>
<p>引用：<a href="https://mp.weixin.qq.com/s/iw6Vgm9odYSaeKTiofTVnw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/iw6Vgm9odYSaeKTiofTVnw</a></p>
<p>  java存在四种引用：强引用、软引用、弱引用、虚引用。</p>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>Java的内存分配和内存回收，都是由jvm去处理，一个对象是否可以被回收，主要看是否有引用指向此对象，说的专业点，叫可达性分析。</p>
<p><strong>Java设计这四种引用的主要目的有两个：</strong></p>
<ul>
<li>可以让程序员通过代码的方式来决定某个对象的生命周期；</li>
<li>主动利用垃圾回收。</li>
</ul>
<a id="more"></a>





<h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>强引用是最普遍的一种引用，我们写的代码，99.9999%都是强引用，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>



<p>这种就是强引用了，是不是在代码中随处可见，最亲切。</p>
<p><strong>只要某个对象有强引用与之关联，这个对象永远不会被回收，即使内存不足，JVM宁愿抛出OOM，也不会去回收。</strong></p>
<p>那么什么时候才可以被回收呢？当强引用和对象之间的关联被中断了，就可以被回收了。</p>
<p>我们可以手动把关联给中断了，方法也特别简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">o = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>



<p>我们可以手动调用GC，看看如果强引用和对象之间的关联被中断了，资源会不会被回收，为了更方便、更清楚的观察到回收的情况，我们需要新写一个类，然后重写finalize方法，下面我们来进行这个实验：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Student 被回收了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">Student 被回收了</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>







<h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p><strong>当内存不足，会触发JVM的GC，如果GC后，内存还是不足，就会把软引用的包裹的对象给干掉，也就是只有在内存不足，JVM才会回收该对象。</strong></p>
<p>下面先来看看如何创建一个软引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SoftReference&lt;Student&gt;studentSoftReference=<span class="keyword">new</span> SoftReference&lt;Student&gt;(<span class="keyword">new</span> Student());</span><br></pre></td></tr></table></figure>

<p>软引用就是把对象用SoftReference包裹一下，当我们需要从软引用对象获得包裹的对象，只要get一下就可以了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SoftReference&lt;Student&gt;studentSoftReference=<span class="keyword">new</span> SoftReference&lt;Student&gt;(<span class="keyword">new</span> Student());</span><br><span class="line">Student student = studentSoftReference.get();</span><br><span class="line">System.out.println(student);</span><br></pre></td></tr></table></figure>

<p>还是一样的，必须做实验，才能加深印象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SoftReference&lt;<span class="keyword">byte</span>[]&gt; softReference = <span class="keyword">new</span> SoftReference&lt;<span class="keyword">byte</span>[]&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">10</span>]);</span><br><span class="line">System.out.println(softReference.get());</span><br><span class="line">System.gc();</span><br><span class="line">System.out.println(softReference.get());</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>];</span><br><span class="line">System.out.println(softReference.get());</span><br></pre></td></tr></table></figure>

<p>我定义了一个软引用对象，里面包裹了byte[]，byte[]占用了10M，然后又创建了10Mbyte[]。</p>
<p>运行程序，需要带上一个参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xmx20M</span><br></pre></td></tr></table></figure>

<p>代表最大堆内存是20M。</p>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[B@11d7fff</span><br><span class="line">[B@11d7fff</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<p>可以很清楚的看到手动完成GC后，软引用对象包裹的byte[]还活的好好的，但是当我们创建了一个10M的byte[]后，最大堆内存不够了，所以把软引用对象包裹的byte[]给干掉了，如果不干掉，就会抛出OOM。</p>
<p>软引用到底有什么用呢？比较适合用作缓存，当内存足够，可以正常的拿到缓存，当内存不够，就会先干掉缓存，不至于马上抛出OOM。</p>
<h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>虚引用又被称为幻影引用，我们来看看它的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReferenceQueue queue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">PhantomReference&lt;<span class="keyword">byte</span>[]&gt; reference = <span class="keyword">new</span> PhantomReference&lt;<span class="keyword">byte</span>[]&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span>], queue);</span><br><span class="line">System.out.println(reference.get());</span><br></pre></td></tr></table></figure>

<p>虚引用的使用和上面说的软引用、弱引用的区别还是挺大的，我们先不管ReferenceQueue 是个什么鬼，直接来运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">null</span><br></pre></td></tr></table></figure>

<p>竟然打印出了null，我们来看看get方法的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是几个意思，竟然直接返回了null。</p>
<p>这就是虚引用特点之一了：<strong>无法通过虚引用来获取对一个对象的真实引用。</strong></p>
<p>那虚引用存在的意义是什么呢？这就要回到我们上面的代码了，我们把代码复制下，以免大家再次往上翻：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReferenceQueue queue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">PhantomReference&lt;<span class="keyword">byte</span>[]&gt; reference = <span class="keyword">new</span> PhantomReference&lt;<span class="keyword">byte</span>[]&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span>], queue);</span><br><span class="line">System.out.println(reference.get());</span><br></pre></td></tr></table></figure>

<p>创建虚引用对象，我们除了把包裹的对象传了进去，还传了一个ReferenceQueue，从名字就可以看出它是一个队列。</p>
<p>虚引用的特点之二就是 <strong>虚引用必须与ReferenceQueue一起使用，当GC准备回收一个对象，如果发现它还有虚引用，就会在回收之前，把这个虚引用加入到与之关联的ReferenceQueue中。</strong></p>
<p>我们来用代码实践下吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    ReferenceQueue queue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">    List&lt;<span class="keyword">byte</span>[]&gt; bytes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    PhantomReference&lt;Student&gt; reference = <span class="keyword">new</span> PhantomReference&lt;Student&gt;(<span class="keyword">new</span> Student(),queue);</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>;i++ ) &#123;</span><br><span class="line">            bytes.add(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Reference poll = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (poll != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"虚引用被回收了："</span> + poll);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    scanner.hasNext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student 被回收了</span><br><span class="line">虚引用被回收了：java.lang.ref.PhantomReference@<span class="number">1</span>ade6f1</span><br></pre></td></tr></table></figure>

<p>我们简单的分析下代码：</p>
<blockquote>
<p>第一个线程往集合里面塞数据，随着数据越来越多，肯定会发生GC。<br>第二个线程死循环，从queue里面拿数据，如果拿出来的数据不是null，就打印出来。</p>
</blockquote>
<p>从运行结果可以看到：<strong>当发生GC，虚引用就会被回收，并且会把回收的通知放到ReferenceQueue中。</strong></p>
<p>虚引用有什么用呢？在NIO中，就运用了虚引用管理堆外内存。</p>
<p>##弱引用</p>
<p>弱引用的使用和软引用类似，只是关键字变成了WeakReference：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WeakReference&lt;<span class="keyword">byte</span>[]&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;<span class="keyword">byte</span>[]&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">10</span>]);</span><br><span class="line">System.out.println(weakReference.get());</span><br></pre></td></tr></table></figure>

<p>弱引用的特点是不管内存是否足够，只要发生GC，都会被回收：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WeakReference&lt;<span class="keyword">byte</span>[]&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;<span class="keyword">byte</span>[]&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span>]);</span><br><span class="line">System.out.println(weakReference.get());</span><br><span class="line">System.gc();</span><br><span class="line">System.out.println(weakReference.get());</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[B@11d7fff</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<p>可以很清楚的看到明明内存还很充足，但是触发了GC，资源还是被回收了。弱引用在很多地方都有用到，比如ThreadLocal、WeakHashMap。</p>
<h3 id="虚引用-1"><a href="#虚引用-1" class="headerlink" title="虚引用"></a>虚引用</h3><script src="https://utteranc.es/client.js" repo="lanshusheng/lanshusheng.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async>
</script>]]></content>
      <categories>
        <category>gc</category>
      </categories>
      <tags>
        <tag>垃圾回收</tag>
        <tag>引用</tag>
        <tag>内存分配</tag>
      </tags>
  </entry>
  <entry>
    <title>stream 常见函数的一些梳理</title>
    <url>/2020/08/10/stream/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>lambda函数</category>
      </categories>
      <tags>
        <tag>stream</tag>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>基于redis的多维度排序</title>
    <url>/2020/08/10/%E5%9F%BA%E4%BA%8Eredis%E7%9A%84%E5%A4%9A%E5%9B%A0%E5%AD%90%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><h3 id="为什么需要多维度排序"><a href="#为什么需要多维度排序" class="headerlink" title="为什么需要多维度排序"></a>为什么需要多维度排序</h3><p>   常见的feed流架构下，我们需要很多的排序流，比如 雪球的评论流，需要按赞和时间进行排序（有赞的评论，先按赞排序。没有赞的评论按时间倒排）。</p>
<p>  需求：按赞和评论排序。QPS &gt; 5000，需要缓存。</p>
<p>常见设计方案：</p>
<ol>
<li>feed流里面存储按时间排序feed流。定时或者异步计算时间因子。但是这个时候会面临一个问题，你的feed流永远计算不是实时的。你的热贴流永远计算不及时。所以方案一不可取。</li>
<li>采用bit方式, 统一或若干小domain(比如点赞数), 再在排序后面接bit控制。核心在于如何计算score。</li>
</ol>
<a id="more"></a>

<h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><p>  redis版本：4.0</p>
<p> 关于feed流：需要了解常见feed流架构。了解sort set。</p>
<h1 id="关于sort-set"><a href="#关于sort-set" class="headerlink" title="关于sort set"></a>关于sort set</h1><p>见：<a href="https://redis.readthedocs.io/en/2.4/sorted_set.html" target="_blank" rel="noopener">https://redis.readthedocs.io/en/2.4/sorted_set.html</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加单个元素</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZADD page_rank 10 google.com</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加多个元素</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZADD page_rank 9 baidu.com 8 bing.com</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</span><br><span class="line">1) <span class="string">"bing.com"</span></span><br><span class="line">2) <span class="string">"8"</span></span><br><span class="line">3) <span class="string">"baidu.com"</span></span><br><span class="line">4) <span class="string">"9"</span></span><br><span class="line">5) <span class="string">"google.com"</span></span><br><span class="line">6) <span class="string">"10"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加已存在元素，且 score 值不变</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZADD page_rank 10 google.com</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES  <span class="comment"># 没有改变</span></span><br><span class="line">1) <span class="string">"bing.com"</span></span><br><span class="line">2) <span class="string">"8"</span></span><br><span class="line">3) <span class="string">"baidu.com"</span></span><br><span class="line">4) <span class="string">"9"</span></span><br><span class="line">5) <span class="string">"google.com"</span></span><br><span class="line">6) <span class="string">"10"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加已存在元素，但是改变 score 值</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZADD page_rank 6 bing.com</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES  <span class="comment"># bing.com 元素的score值被改变</span></span><br><span class="line">1) <span class="string">"bing.com"</span></span><br><span class="line">2) <span class="string">"6"</span></span><br><span class="line">3) <span class="string">"baidu.com"</span></span><br><span class="line">4) <span class="string">"9"</span></span><br><span class="line">5) <span class="string">"google.com"</span></span><br><span class="line">6) <span class="string">"10"</span></span><br></pre></td></tr></table></figure>



<p>Zrange 返回有序集<code>key</code>中，所有<code>score</code>值介于<code>min</code>和<code>max</code>之间(包括等于<code>min</code>或<code>max</code>)的成员。有序集成员按<code>score</code>值递增(从小到大)次序排列。</p>
<p>具有相同<code>score</code>值的成员按字典序(<a href="http://en.wikipedia.org/wiki/Lexicographical_order" target="_blank" rel="noopener">lexicographical order</a>)来排列(该属性是有序集提供的，不需要额外的计算)。</p>
<p>可选的<code>LIMIT</code>参数指定返回结果的数量及区间(就像SQL中的<code>SELECT LIMIT offset, count</code>)，注意当<code>offset</code>很大时，定位<code>offset</code>的操作可能需要遍历整个有序集，此过程最坏复杂度为O(N)时间。</p>
<h1 id="score-聚合"><a href="#score-聚合" class="headerlink" title="score 聚合"></a>score 聚合</h1><p>在这里，我们先简单定义各个因子的权重：点赞数（like_count） &gt; 回复数(reply_count) &gt; 按时间排序(time)。</p>
<p>为了尽量减少我们score值占用的bit位。</p>
<p>为了描述清楚。这里用一个例子：当前评论，点赞数为 5 ， 回复数为 8 ，时间戳为 12312312</p>
<p>默认 score为0。</p>
<ul>
<li>因子权重最低的放在小数位。其实时间戳并不连续，需要发号器（snowflake算法）使时间戳因子连续。现在的 score = 0.12312312  。</li>
<li>第二维度为回复数。这里需要第一个计算手段：计算出当前数据库里面，回复数最多的那个评论的数目。假设当前最大回复数为n，这里取10000。在这里做最大数据保护，扩展100 倍，即，我们任务，未来会有一个评论的回复数会到100w（注意：只是保护设计，生产环境需要详细评估，基于你的用户体量来分析，考虑互联网的2、8分布）。此时的score = 8.12312312。</li>
<li>第三个维度为点赞数。上一步的最大回复数用在这里。即第三个维度的score = 100w * 5 + 8 + 0.12312312 </li>
</ul>
<p>即 ： score = like_count * ( max(reply_count) * 100) + reply_count + 0.time 。</p>
<h2 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h2><p>当用户有点赞时，即like_count &gt; 0：</p>
<p>用户的  score = like_count * ( max(reply_count) * 100) + reply_count + 0.time  &gt;  0 *  ( max(reply_count) * 100) + reply_count + 0.time  &gt;=  reply_count + 0.time 。</p>
<p>即：当用户的评论有赞时，永远会按赞排序。</p>
<p>回复同理，当like_count = 0、 reply_count &gt; 0 时：</p>
<p>score = like_count * ( max(reply_count) * 100) + reply_count + 0.time  &gt;  0 *  ( max(reply_count) * 100) + 0* reply_count + 0.time  &gt;=  0.time 。</p>
<p>即：当用户的评论没有赞时，但有评论时、永远会按时间排序。</p>
<p>验证：当我们有三个评论</p>
<ul>
<li>A (点赞 3， 评论 5，时间 100 ) 。 score = 3000005.100</li>
<li>B (点赞 4， 评论 5，时间 100 )。 score = 4000005.100</li>
<li>C (点赞 3， 评论 4，时间 99 )。 score = 3000004.99</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis&gt; ZRANGE add 3000005.100 A </span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE add 4000005.100 B</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE add 3000004.99 C </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">redis&gt; ZREVRANGE page_rank 0 -1   # bing.com 元素的score值被改变</span><br><span class="line">1) &quot;B&quot;</span><br><span class="line">2) &quot;A&quot;</span><br><span class="line">3) &quot;C&quot;</span><br></pre></td></tr></table></figure>











<script src="https://utteranc.es/client.js" repo="lanshusheng/lanshusheng.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async>
</script>]]></content>
      <categories>
        <category>redis使用</category>
      </categories>
      <tags>
        <tag>feed流</tag>
        <tag>redis</tag>
        <tag>sorted-set</tag>
        <tag>多因子排序</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程synchronized</title>
    <url>/2021/03/30/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>记录一些自己感触！</p>
<p><img src="/2021/03/30/%E5%A4%9A%E7%BA%BF%E7%A8%8B/img/01_02.jpg" alt="01_02"></p>
<a id="more"></a>

<h2 id="线程同步的基本概念"><a href="#线程同步的基本概念" class="headerlink" title="线程同步的基本概念"></a>线程同步的基本概念</h2><p><strong>synchronized</strong></p>
<p>对于线程而言，加锁是保证线程安全的必要条件。即访问某一段代码或者某临界资源的时候是需要有一把锁的概念在这儿的。</p>
<p>第一个属性：给临界资源加锁。</p>
<p>如图：想要访问如图的资源则使用如下的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*synchronized关键字</span></span><br><span class="line"><span class="comment">*对某个对象加锁</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">private</span> Object o = <span class="keyword">new</span> Object();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(o) &#123; <span class="comment">//任何线程要想执行下面的代码，必须先拿到o的锁</span></span><br><span class="line">			count--;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(T<span class="class">.<span class="keyword">class</span>) </span>&#123; <span class="comment">//考虑一下这里写synchronized(this)是否可以？</span></span><br><span class="line">			count --;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//不可以，是几方面的原因“"1:静态资源无法访问非静态资源，所以this直接无法访问。2、方法区和堆内资源没有指向，无法直接访问"</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" m1 start..."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" m1 end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" m2 start "</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1();</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" m2 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*new Thread(()-&gt;t.m1(), "t1").start();</span></span><br><span class="line"><span class="comment">		new Thread(()-&gt;t.m2(), "t2").start();*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(t::m1, <span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(t::m2, <span class="string">"t2"</span>).start();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		//1.8之前的写法</span></span><br><span class="line"><span class="comment">		new Thread(new Runnable() &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">			@Override</span></span><br><span class="line"><span class="comment">			public void run() &#123;</span></span><br><span class="line"><span class="comment">				t.m1();</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">		&#125;);</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​       </p>
<p>再来看synchronized的另外一个属性：可重入，是synchronized必须了解的一个概念。</p>
<p>如果是一个同步方法调用另外一个同步方法，有一个方法加了锁，另外一个方法也需要加锁，加的是同一把锁也是同一个线程，那这个时候申请仍然会得到该对象的锁。比如说是synchronized可重入的，有一个方法m1 是synchronized有一个方法m2也是synchrionzed，m1里能不能调m2。我们m1开始的时候这个线程得到了这把锁，然后在m1里面调用m2，如果说这个时候不允许任何线程再来拿这把锁的时候就死锁了。这个时候调m2它发现是同一个线程，因为你m2也需要申请这把锁，它发现是同一个线程申请的这把锁，允许，可以没问题，这就叫可重入锁。</p>
<p>即：同一个线程可以获取当前锁（同一个锁）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"m1 start"</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		m2();</span><br><span class="line">		System.out.println(<span class="string">"m1 end"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">"m2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">new</span> T().m1();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>














]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>synchronized</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>AQS</title>
    <url>/2021/04/01/AQS/</url>
    <content><![CDATA[<p>先上一段源码，看了半天讲解，回头发现还是得看源码[cry]。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> AbstractQueuedSynchronizer&#125; instance</span></span><br><span class="line"><span class="comment"> * with initial synchronization state of zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractQueuedSynchronizer</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wait queue node class.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The wait queue is a variant of a "CLH" (Craig, Landin, and</span></span><br><span class="line"><span class="comment"> * Hagersten) lock queue. CLH locks are normally used for</span></span><br><span class="line"><span class="comment"> * spinlocks.  We instead use them for blocking synchronizers, but</span></span><br><span class="line"><span class="comment"> * use the same basic tactic of holding some of the control</span></span><br><span class="line"><span class="comment"> * information about a thread in the predecessor of its node.  A</span></span><br><span class="line"><span class="comment"> * "status" field in each node keeps track of whether a thread</span></span><br><span class="line"><span class="comment"> * should block.  A node is signalled when its predecessor</span></span><br><span class="line"><span class="comment"> * releases.  Each node of the queue otherwise serves as a</span></span><br><span class="line"><span class="comment"> * specific-notification-style monitor holding a single waiting</span></span><br><span class="line"><span class="comment"> * thread. The status field does NOT control whether threads are</span></span><br><span class="line"><span class="comment"> * granted locks etc though.  A thread may try to acquire if it is</span></span><br><span class="line"><span class="comment"> * first in the queue. But being first does not guarantee success;</span></span><br><span class="line"><span class="comment"> * it only gives the right to contend.  So the currently released</span></span><br><span class="line"><span class="comment"> * contender thread may need to rewait.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;To enqueue into a CLH lock, you atomically splice it in as new</span></span><br><span class="line"><span class="comment"> * tail. To dequeue, you just set the head field.</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *      +------+  prev +-----+       +-----+</span></span><br><span class="line"><span class="comment"> * head |      | &lt;---- |     | &lt;---- |     |  tail</span></span><br><span class="line"><span class="comment"> *      +------+       +-----+       +-----+</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Insertion into a CLH queue requires only a single atomic</span></span><br><span class="line"><span class="comment"> * operation on "tail", so there is a simple atomic point of</span></span><br><span class="line"><span class="comment"> * demarcation from unqueued to queued. Similarly, dequeuing</span></span><br><span class="line"><span class="comment"> * involves only updating the "head". However, it takes a bit</span></span><br><span class="line"><span class="comment"> * more work for nodes to determine who their successors are,</span></span><br><span class="line"><span class="comment"> * in part to deal with possible cancellation due to timeouts</span></span><br><span class="line"><span class="comment"> * and interrupts.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The "prev" links (not used in original CLH locks), are mainly</span></span><br><span class="line"><span class="comment"> * needed to handle cancellation. If a node is cancelled, its</span></span><br><span class="line"><span class="comment"> * successor is (normally) relinked to a non-cancelled</span></span><br><span class="line"><span class="comment"> * predecessor. For explanation of similar mechanics in the case</span></span><br><span class="line"><span class="comment"> * of spin locks, see the papers by Scott and Scherer at</span></span><br><span class="line"><span class="comment"> * http://www.cs.rochester.edu/u/scott/synchronization/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;We also use "next" links to implement blocking mechanics.</span></span><br><span class="line"><span class="comment"> * The thread id for each node is kept in its own node, so a</span></span><br><span class="line"><span class="comment"> * predecessor signals the next node to wake up by traversing</span></span><br><span class="line"><span class="comment"> * next link to determine which thread it is.  Determination of</span></span><br><span class="line"><span class="comment"> * successor must avoid races with newly queued nodes to set</span></span><br><span class="line"><span class="comment"> * the "next" fields of their predecessors.  This is solved</span></span><br><span class="line"><span class="comment"> * when necessary by checking backwards from the atomically</span></span><br><span class="line"><span class="comment"> * updated "tail" when a node's successor appears to be null.</span></span><br><span class="line"><span class="comment"> * (Or, said differently, the next-links are an optimization</span></span><br><span class="line"><span class="comment"> * so that we don't usually need a backward scan.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Cancellation introduces some conservatism to the basic</span></span><br><span class="line"><span class="comment"> * algorithms.  Since we must poll for cancellation of other</span></span><br><span class="line"><span class="comment"> * nodes, we can miss noticing whether a cancelled node is</span></span><br><span class="line"><span class="comment"> * ahead or behind us. This is dealt with by always unparking</span></span><br><span class="line"><span class="comment"> * successors upon cancellation, allowing them to stabilize on</span></span><br><span class="line"><span class="comment"> * a new predecessor, unless we can identify an uncancelled</span></span><br><span class="line"><span class="comment"> * predecessor who will carry this responsibility.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;CLH queues need a dummy header node to get started. But</span></span><br><span class="line"><span class="comment"> * we don't create them on construction, because it would be wasted</span></span><br><span class="line"><span class="comment"> * effort if there is never contention. Instead, the node</span></span><br><span class="line"><span class="comment"> * is constructed and head and tail pointers are set upon first</span></span><br><span class="line"><span class="comment"> * contention.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Threads waiting on Conditions use the same nodes, but</span></span><br><span class="line"><span class="comment"> * use an additional link. Conditions only need to link nodes</span></span><br><span class="line"><span class="comment"> * in simple (non-concurrent) linked queues because they are</span></span><br><span class="line"><span class="comment"> * only accessed when exclusively held.  Upon await, a node is</span></span><br><span class="line"><span class="comment"> * inserted into a condition queue.  Upon signal, the node is</span></span><br><span class="line"><span class="comment"> * transferred to the main queue.  A special value of status</span></span><br><span class="line"><span class="comment"> * field is used to mark which queue a node is on.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Thanks go to Dave Dice, Mark Moir, Victor Luchangco, Bill</span></span><br><span class="line"><span class="comment"> * Scherer and Michael Scott, along with members of JSR-166</span></span><br><span class="line"><span class="comment"> * expert group, for helpful ideas, discussions, and critiques</span></span><br><span class="line"><span class="comment"> * on the design of this class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate successor's thread needs unparking */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment">     * unconditionally propagate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Status field, taking on only the values:</span></span><br><span class="line"><span class="comment">     *   SIGNAL:     The successor of this node is (or will soon be)</span></span><br><span class="line"><span class="comment">     *               blocked (via park), so the current node must</span></span><br><span class="line"><span class="comment">     *               unpark its successor when it releases or</span></span><br><span class="line"><span class="comment">     *               cancels. To avoid races, acquire methods must</span></span><br><span class="line"><span class="comment">     *               first indicate they need a signal,</span></span><br><span class="line"><span class="comment">     *               then retry the atomic acquire, and then,</span></span><br><span class="line"><span class="comment">     *               on failure, block.</span></span><br><span class="line"><span class="comment">     *   CANCELLED:  This node is cancelled due to timeout or interrupt.</span></span><br><span class="line"><span class="comment">     *               Nodes never leave this state. In particular,</span></span><br><span class="line"><span class="comment">     *               a thread with cancelled node never again blocks.</span></span><br><span class="line"><span class="comment">     *   CONDITION:  This node is currently on a condition queue.</span></span><br><span class="line"><span class="comment">     *               It will not be used as a sync queue node</span></span><br><span class="line"><span class="comment">     *               until transferred, at which time the status</span></span><br><span class="line"><span class="comment">     *               will be set to 0. (Use of this value here has</span></span><br><span class="line"><span class="comment">     *               nothing to do with the other uses of the</span></span><br><span class="line"><span class="comment">     *               field, but simplifies mechanics.)</span></span><br><span class="line"><span class="comment">     *   PROPAGATE:  A releaseShared should be propagated to other</span></span><br><span class="line"><span class="comment">     *               nodes. This is set (for head node only) in</span></span><br><span class="line"><span class="comment">     *               doReleaseShared to ensure propagation</span></span><br><span class="line"><span class="comment">     *               continues, even if other operations have</span></span><br><span class="line"><span class="comment">     *               since intervened.</span></span><br><span class="line"><span class="comment">     *   0:          None of the above</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The values are arranged numerically to simplify use.</span></span><br><span class="line"><span class="comment">     * Non-negative values mean that a node doesn't need to</span></span><br><span class="line"><span class="comment">     * signal. So, most code doesn't need to check for particular</span></span><br><span class="line"><span class="comment">     * values, just for sign.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The field is initialized to 0 for normal sync nodes, and</span></span><br><span class="line"><span class="comment">     * CONDITION for condition nodes.  It is modified using CAS</span></span><br><span class="line"><span class="comment">     * (or when possible, unconditional volatile writes).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Link to predecessor node that current node/thread relies on</span></span><br><span class="line"><span class="comment">     * for checking waitStatus. Assigned during enqueuing, and nulled</span></span><br><span class="line"><span class="comment">     * out (for sake of GC) only upon dequeuing.  Also, upon</span></span><br><span class="line"><span class="comment">     * cancellation of a predecessor, we short-circuit while</span></span><br><span class="line"><span class="comment">     * finding a non-cancelled one, which will always exist</span></span><br><span class="line"><span class="comment">     * because the head node is never cancelled: A node becomes</span></span><br><span class="line"><span class="comment">     * head only as a result of successful acquire. A</span></span><br><span class="line"><span class="comment">     * cancelled thread never succeeds in acquiring, and a thread only</span></span><br><span class="line"><span class="comment">     * cancels itself, not any other node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Link to the successor node that the current node/thread</span></span><br><span class="line"><span class="comment">     * unparks upon release. Assigned during enqueuing, adjusted</span></span><br><span class="line"><span class="comment">     * when bypassing cancelled predecessors, and nulled out (for</span></span><br><span class="line"><span class="comment">     * sake of GC) when dequeued.  The enq operation does not</span></span><br><span class="line"><span class="comment">     * assign next field of a predecessor until after attachment,</span></span><br><span class="line"><span class="comment">     * so seeing a null next field does not necessarily mean that</span></span><br><span class="line"><span class="comment">     * node is at end of queue. However, if a next field appears</span></span><br><span class="line"><span class="comment">     * to be null, we can scan prev's from the tail to</span></span><br><span class="line"><span class="comment">     * double-check.  The next field of cancelled nodes is set to</span></span><br><span class="line"><span class="comment">     * point to the node itself instead of null, to make life</span></span><br><span class="line"><span class="comment">     * easier for isOnSyncQueue.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The thread that enqueued this node.  Initialized on</span></span><br><span class="line"><span class="comment">     * construction and nulled out after use.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Link to next node waiting on condition, or the special</span></span><br><span class="line"><span class="comment">     * value SHARED.  Because condition queues are accessed only</span></span><br><span class="line"><span class="comment">     * when holding in exclusive mode, we just need a simple</span></span><br><span class="line"><span class="comment">     * linked queue to hold nodes while they are waiting on</span></span><br><span class="line"><span class="comment">     * conditions. They are then transferred to the queue to</span></span><br><span class="line"><span class="comment">     * re-acquire. And because conditions can only be exclusive,</span></span><br><span class="line"><span class="comment">     * we save a field by using special value to indicate shared</span></span><br><span class="line"><span class="comment">     * mode.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if node is waiting in shared mode.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns previous node, or throws NullPointerException if null.</span></span><br><span class="line"><span class="comment">     * Use when predecessor cannot be null.  The null check could</span></span><br><span class="line"><span class="comment">     * be elided, but is present to help the VM.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the predecessor of this node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AQS内部有一个核心状态为<code>state</code>。所有通过AQS实现功能的类都是通过修改state的状态来操作线程的同步状态。比如在<code>ReentrantLock</code>中，一个锁中只有一个<code>state</code>状态，当<code>state</code>为0时，代表所有线程没有获取锁，当<code>state</code>为1时，代表有线程获取到了锁。通过是否能把<code>state</code>从0设置成1，当然，设置的方式是使用CAS设置，代表一个线程是否获取锁成功。</p>
<p>AQS提供了操作state的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Cas 真是神奇。</p>
</blockquote>
<p>AQS内部维护一个线程的队列。队列由内部的节点组成。</p>
<p>队列的节点为<code>Node</code>,节点分为<code>SHARED</code>和<code>EXCLUSIVE</code>分别时共享模式的节点和独占模式的节点。</p>
<p>节点的等待状态为<code>waitStatus</code></p>
<ul>
<li>CANCELLED（1）：取消状态，当线程不再希望获取锁时，设置为取消状态</li>
<li>SIGNAL（-1）：当前节点的后继者处于等待状态，当前节点的线程如果释放或取消了同步状态，通知后继节点</li>
<li>CONDITION（-2）：等待队列的等待状态，当调用signal()时，进入同步队列</li>
<li>PROPAGATE（-3）：共享模式，同步状态的获取的可传播状态</li>
<li>0：初始状态</li>
</ul>
<p>同样需要使用CAS的方式进行设置。</p>
<p>下面通过<code>ReentrantLock</code>和<code>ReentrantReadWriteLock</code>来解析AQS的独占模式和共享模式。</p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>concurrentHashMap</title>
    <url>/2021/04/20/concurrentHashMap/</url>
    <content><![CDATA[<p>一、Hash map 的一些简单介绍</p>
<p><strong>真难啊，记录一个这个过程，最难的在于扩容，数据迁移操作不容易看懂。</strong></p>
<p><img src="/2021/04/20/concurrentHashMap/hash.png" alt="hash"></p>
<a id="more"></a>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这构造函数里，什么都不干</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这个初始化方法有点意思，通过提供初始容量，计算了 sizeCtl，sizeCtl = 【 (<span class="number">1.5</span> * initialCapacity + <span class="number">1</span>)，然后向上取最近的 <span class="number">2</span> 的 n 次方】。如 initialCapacity 为 <span class="number">10</span>，那么得到 sizeCtl 为 <span class="number">16</span>，如果 initialCapacity 为 <span class="number">11</span>，得到 sizeCtl 为 <span class="number">32</span>。</span><br></pre></td></tr></table></figure>



<p>然后是 put的全过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 得到 hash 值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">// 用于记录相应链表的长度</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 如果数组"空"，进行数组初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 初始化数组，后面会详细介绍</span></span><br><span class="line">            tab = initTable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找该 hash 值对应的数组下标，得到第一个节点 f</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果数组该位置为空，</span></span><br><span class="line">            <span class="comment">//    用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了</span></span><br><span class="line">            <span class="comment">//          如果 CAS 失败，那就是有并发操作，进到下一个循环就好了</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// hash 居然可以等于 MOVED，这个需要到后面才能看明白，不过从名字上也能猜到，肯定是因为需要扩容了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 帮助数据迁移，这个等到看完数据迁移部分的介绍后，再理解这个就很简单了</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 到这里就是说，f 是该位置的头结点，而且不为空</span></span><br><span class="line"></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 获取数组该位置的头结点的监视器锁，每个数据的头部才会作为实际锁的位置。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">// 头结点的 hash 值大于 0，说明是链表</span></span><br><span class="line">                        <span class="comment">// 用于累加，记录链表的长度</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 遍历链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 如果发现了"相等"的 key，判断是否要进行值覆盖，然后也就可以 break 了</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 到了链表的最末端，将这个新值放到链表的最后面</span></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123; <span class="comment">// 红黑树</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// 调用红黑树的插值方法插入新节点</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// binCount != 0 说明上面在做链表操作</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断是否要将链表转换为红黑树，临界值和 HashMap 一样，也是 8</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">// 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换，</span></span><br><span class="line">                    <span class="comment">// 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树</span></span><br><span class="line">                    <span class="comment">//    具体源码我们就不看了，扩容部分后面说</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>put 的主流程看完了，但是至少留下了几个问题，第一个是初始化，第二个是扩容，第三个是帮助数据迁移，这些我们都会在后面进行一一介绍。<br>初始化数组：initTable<br>这个比较简单，主要就是初始化一个<strong>合适大小</strong>的数组，然后会设置 sizeCtl。<br>初始化方法中的并发问题是通过对 sizeCtl 进行一个 CAS 操作来控制的。</p>
<h3 id="初始化的问题"><a href="#初始化的问题" class="headerlink" title="初始化的问题"></a>初始化的问题</h3><p>先是初始化的问题：initTable<br>这个比较简单，主要就是初始化一个<strong>合适大小</strong>的数组，然后会设置 sizeCtl。<br>初始化方法中的并发问题是通过对 sizeCtl 进行一个 CAS 操作来控制的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化的"功劳"被其他线程"抢去"了</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">// CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// DEFAULT_CAPACITY 默认初始容量是 16</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="comment">// 初始化数组，长度为 16 或初始化时提供的长度</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    <span class="comment">// 将这个数组赋值给 table，table 是 volatile 的</span></span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">// 如果 n 为 16 的话，那么这里 sc = 12</span></span><br><span class="line">                    <span class="comment">// 其实就是 0.75 * n</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 设置 sizeCtl 为 sc，我们就当是 12 吧</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="链表转红黑树-treeifyBin"><a href="#链表转红黑树-treeifyBin" class="headerlink" title="链表转红黑树: treeifyBin"></a>链表转红黑树: treeifyBin</h3><p>前面我们在 put 源码分析也说过，treeifyBin 不一定就会进行红黑树转换，也可能是仅仅做数组扩容。我们还是进行源码分析吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// MIN_TREEIFY_CAPACITY 为 64</span></span><br><span class="line">        <span class="comment">// 所以，如果数组长度小于 64 的时候，其实也就是 32 或者 16 或者更小的时候，会进行数组扩容</span></span><br><span class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            <span class="comment">// 后面我们再详细分析这个方法</span></span><br><span class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// b 是头结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    <span class="comment">// 下面就是遍历链表，建立一颗红黑树</span></span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; p =</span><br><span class="line">                            <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                              <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">                            hd = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将红黑树设置到数组相应位置中</span></span><br><span class="line">                    setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="扩容：tryPresize"><a href="#扩容：tryPresize" class="headerlink" title="扩容：tryPresize"></a>扩容：tryPresize</h3><p>如果说 Java8 ConcurrentHashMap 的源码不简单，那么说的就是扩容操作和迁移操作。</p>
<p>这个方法要完完全全看懂还需要看之后的 transfer 方法，读者应该提前知道这点。</p>
<p>这里的扩容也是做翻倍扩容的，扩容后数组容量为原来的 2 倍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先要说明的是，方法参数 size 传进来的时候就已经翻了倍了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryPresize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// c：size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。</span></span><br><span class="line">    <span class="keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY :</span><br><span class="line">        tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab = table; <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个 if 分支和之前说的初始化数组的代码基本上是一样的，在这里，我们可以不用管这块代码</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            n = (sc &gt; c) ? sc : c;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                        table = nt;</span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>); <span class="comment">// 0.75 * n</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">            <span class="comment">// 我没看懂 rs 的真正含义是什么，不过也关系不大</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Node&lt;K,V&gt;[] nt;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 2\. 用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法</span></span><br><span class="line">                <span class="comment">//    此时 nextTab 不为 null</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 1\. 将 sizeCtl 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</span></span><br><span class="line">            <span class="comment">//     我是没看懂这个值真正的意义是什么？不过可以计算出来的是，结果是一个比较大的负数</span></span><br><span class="line">            <span class="comment">//  调用 transfer 方法，此时 nextTab 参数为 null</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个方法的核心在于 sizeCtl 值的操作，首先将其设置为一个负数，然后执行 transfer(tab, null)，再下一个循环将 sizeCtl 加 1，并执行 transfer(tab, nt)，之后可能是继续 sizeCtl 加 1，并执行 transfer(tab, nt)。<br>所以，可能的操作就是执行 <strong>1 次 transfer(tab, null) + 多次 transfer(tab, nt)</strong>，这里怎么结束循环的需要看完 transfer 源码才清楚。<br>数据迁移：transfer<br>下面这个方法很点长，将原来的 tab 数组的元素迁移到新的 nextTab 数组中。<br>虽然我们之前说的 tryPresize 方法中多次调用 transfer 不涉及多线程，但是这个 transfer 方法可以在其他地方被调用，典型地，我们之前在说 put 方法的时候就说过了，请往上看 put 方法，是不是有个地方调用了 helpTransfer 方法，helpTransfer 方法会调用 transfer 方法的。<br>此方法支持多线程执行，外围调用此方法的时候，会保证第一个发起数据迁移的线程，nextTab 参数为 null，之后再调用此方法的时候，nextTab 不会为 null。<br>阅读源码之前，先要理解并发操作的机制。原数组长度为 n，所以我们有 n 个迁移任务，让每个线程每次负责一个小任务是最简单的，每做完一个任务再检测是否有其他没做完的任务，帮助迁移就可以了，而 Doug Lea 使用了一个 stride，简单理解就是<strong>步长</strong>，每个线程每次负责迁移其中的一部分，如每次迁移 16 个小任务。所以，我们就需要一个全局的调度者来安排哪个线程执行哪几个任务，这个就是属性 transferIndex 的作用。<br>第一个发起数据迁移的线程会将 transferIndex 指向原数组最后的位置，然后<strong>从后往前</strong>的 stride 个任务属于第一个线程，然后将 transferIndex 指向新的位置，再往前的 stride 个任务属于第二个线程，依此类推。当然，这里说的第二个线程不是真的一定指代了第二个线程，也可以是同一个线程，这个读者应该能理解吧。其实就是将一个大的迁移任务分为了一个个任务包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stride 在单核下直接等于 n，多核模式下为 (n&gt;&gt;&gt;3)/NCPU，最小值是 16</span></span><br><span class="line">    <span class="comment">// stride 可以理解为”步长“，有 n 个位置是需要进行迁移的，</span></span><br><span class="line">    <span class="comment">//   将这 n 个任务分为多个任务包，每个任务包有 stride 个任务</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 nextTab 为 null，先进行一次初始化</span></span><br><span class="line">    <span class="comment">//    前面我们说了，外围会保证第一个发起迁移的线程调用此方法时，参数 nextTab 为 null</span></span><br><span class="line">    <span class="comment">//       之后参与迁移的线程调用此方法时，nextTab 不会为 null</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 容量翻倍</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nextTable 是 ConcurrentHashMap 中的属性</span></span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">// transferIndex 也是 ConcurrentHashMap 的属性，用于控制迁移的位置</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ForwardingNode 翻译过来就是正在被迁移的 Node</span></span><br><span class="line">    <span class="comment">// 这个构造方法会生成一个Node，key、value 和 next 都为 null，关键是 hash 为 MOVED</span></span><br><span class="line">    <span class="comment">// 后面我们会看到，原数组中位置 i 处的节点完成迁移工作后，</span></span><br><span class="line">    <span class="comment">//    就会将位置 i 处设置为这个 ForwardingNode，用来告诉其他线程该位置已经处理过了</span></span><br><span class="line">    <span class="comment">//    所以它其实相当于是一个标志。</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// advance 指的是做完了一个位置的迁移工作，可以准备做下一个位置的了</span></span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 下面这个 for 循环，最难理解的在前面，而要看懂它们，应该先看懂后面的，然后再倒回来看</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// i 是位置索引，bound 是边界，注意是从后往前</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这个 while 真的是不好理解</span></span><br><span class="line">        <span class="comment">// advance 为 true 表示可以进行下一个位置的迁移了</span></span><br><span class="line">        <span class="comment">//   简单理解结局：i 指向了 transferIndex，bound 指向了 transferIndex-stride</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 transferIndex 值赋给 nextIndex</span></span><br><span class="line">            <span class="comment">// 这里 transferIndex 一旦小于等于 0，说明原数组的所有位置都有相应的线程去处理了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="comment">// 看括号中的代码，nextBound 是这次迁移任务的边界，注意，是从后往前</span></span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                <span class="comment">// 所有的迁移操作已经完成</span></span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 将新的 nextTab 赋值给 table 属性，完成迁移</span></span><br><span class="line">                table = nextTab;</span><br><span class="line">                <span class="comment">// 重新计算 sizeCtl：n 是原数组长度，所以 sizeCtl 得出的值将是新数组长度的 0.75 倍</span></span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 之前我们说过，sizeCtl 在迁移前会设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2</span></span><br><span class="line">            <span class="comment">// 然后，每有一个线程参与迁移就会将 sizeCtl 加 1，</span></span><br><span class="line">            <span class="comment">// 这里使用 CAS 操作对 sizeCtl 进行减 1，代表做完了属于自己的任务</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 任务结束，方法退出</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 到这里，说明 (sc - 2) == resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT，</span></span><br><span class="line">                <span class="comment">// 也就是说，所有的迁移任务都做完了，也就会进入到上面的 if(finishing)&#123;&#125; 分支了</span></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果位置 i 处是空的，没有任何节点，那么放入刚刚初始化的 ForwardingNode ”空节点“</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="comment">// 该位置处是一个 ForwardingNode，代表该位置已经迁移过了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 对数组该位置处的结点加锁，开始处理数组该位置处的迁移工作</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="comment">// 头结点的 hash 大于 0，说明是链表的 Node 节点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 下面这一块和 Java7 中的 ConcurrentHashMap 迁移是差不多的，</span></span><br><span class="line">                        <span class="comment">// 需要将链表一分为二，</span></span><br><span class="line">                        <span class="comment">//   找到原链表中的 lastRun，然后 lastRun 及其之后的节点是一起进行迁移的</span></span><br><span class="line">                        <span class="comment">//   lastRun 之前的节点需要进行克隆，然后分到两个链表中</span></span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                         <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 其中的一个链表放在新数组的位置 i</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">// 另一个链表放在新数组的位置 i+n</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，</span></span><br><span class="line">                        <span class="comment">//    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">// advance 设置为 true，代表该位置已经迁移完毕</span></span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">// 红黑树的迁移</span></span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果一分为二后，节点数少于 8，那么将红黑树转换回链表</span></span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 将 ln 放置在新数组的位置 i</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">// 将 hn 放置在新数组的位置 i+n</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，</span></span><br><span class="line">                        <span class="comment">//    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">// advance 设置为 true，代表该位置已经迁移完毕</span></span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>























]]></content>
  </entry>
  <entry>
    <title>thread详解</title>
    <url>/2021/04/28/thread%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>转载一遍：最适合新人看的。</p>
<p><a href="https://mp.weixin.qq.com/s/H6XSVlaY1gB6Gse3GR8BeA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/H6XSVlaY1gB6Gse3GR8BeA</a></p>
<a id="more"></a>



<p>闪客：那如果让你来设计这个工具类，你会怎么写呢？我先给你定一个接口，你来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>小宇：emmm，我可能先定义几个成员变量，比如核心线程数、最大线程数 …反正就是那些乱七八糟的参数。</p>
<p>闪客：STOP！小宇呀，你现在深受面试手册的毒害，你先把这些全部的概念忘掉，就说让你写一个最简单的工具类，第一反应，你会怎么写？</p>
<h1 id><a href="#" class="headerlink" title></a></h1><p>小宇：那我可能会这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 新线程：直接创建一个新线程运行</span><br><span class="line">class FlashExecutor implements Executor &#123;</span><br><span class="line">    public void execute(Runnable r) &#123;</span><br><span class="line">        new Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>闪客：嗯嗯很好，你的思路非常棒。</p>
<p>小宇：啊，我这个会不会太 low 了呀，我还以为你会骂我呢。</p>
<p>怎么会， Doug Lea 大神在 JDK 源码注释中给出的就是这样的例子，这是最根本的功能。你在这个基础上，尝试着优化一下？</p>
<h1 id="第二版"><a href="#第二版" class="headerlink" title="第二版"></a>第二版</h1><p>小宇：还能怎么优化呢？这不已经用一个工具类实现了异步执行了嘛！</p>
<p>闪客：我问你一个问题，假如有 10000 个人都调用这个工具类提交任务，那就会创建 10000 个线程来执行，这肯定不合适吧！能不能控制一下线程的数量呢？</p>
<p>小宇：这不难，我可以把这个任务 r 丢到一个 tasks 队列中，然后只启动一个线程，就叫它 <strong>Worker</strong> 线程吧，不断从 tasks 队列中取任务，执行任务。这样无论调用者调用多少次，永远就只有一个 Worker 线程在运行，像这样。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTjxNaj1t0BwIBXIG4UCkqlEibYj2Wc5Mf8QQfaaVPhDFrg3pzVvsDTlCAr6p5XY0FicoWflicEFCVGA/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片"></p>
<p>闪客：太棒了，这个设计有了三个重大的意义：</p>
<p>\1. 控制了线程数量。</p>
<p>\2. 队列不但起到了缓冲的作用，还将任务的提交与执行解耦了。</p>
<p>\3. 最重要的一点是，解决了每次重复创建和销毁线程带来的系统开销。</p>
<p>小宇：哇真的么，这么小的改动有这么多意义呀。</p>
<p>闪客：那当然，不过只有一个后台的工作线程 Worker 会不会少了点？还有如果这个 tasks 队列满了怎么办呢？</p>
<h1 id="第三版"><a href="#第三版" class="headerlink" title="第三版"></a>第三版</h1><p>小宇：哦，的确，只有一个线程在某些场景下是很吃力的，那我把 Worker 线程的数量增加？</p>
<p>闪客：没错，Worker 线程的数量要增加，但是具体数量要让使用者决定，调用时传入，就叫核心线程数 <strong>corePoolSize</strong> 吧。</p>
<p>小宇：好的，那我这样设计。</p>
<p>\1. 初始化线程池时，直接启动 corePoolSize 个工作线程 Worker 先跑着。</p>
<p>\2. 这些 Worker 就是死循环从队列里取任务然后执行。</p>
<p>\3. execute 方法仍然是直接把任务放到队列，但队列满了之后直接抛弃</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTjxNaj1t0BwIBXIG4UCkqlOfYmCibYjWibKLnibRY7Gviccp4Tjw8BujtMtKYpXTuCXKtCkI6iaPJE3gw/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片"></p>
<p>闪客：太完美了，奖励你一块费列罗吧。</p>
<p>小宇：哈哈谢谢，那我先吃一会儿哈。 </p>
<p>闪客：好，你边吃我边说。现在我们已经实现了一个至少不那么丑陋的线程池了，但还有几处小瑕疵，比如初始化的时候，就创建了一堆 Worker 线程在那空跑着，假如此时并没有异步任务提交过来执行，这就有点浪费了。</p>
<p>小宇：哦好像是诶！</p>
<p>闪客：还有，你这队列一满，就直接把新任务丢弃了，这样有些粗暴，能不能让调用者自己决定该怎么处理呢？</p>
<p>小宇：哎呀，想不到我这么温柔的妹纸居然写出了这么粗暴的代码。</p>
<p>闪客：额，你先把费列罗咽下去吧。</p>
<h1 id="第四版"><a href="#第四版" class="headerlink" title="第四版"></a>第四版</h1><p>小宇：我吃完了，现在脑子有点不够用了，得先消化消化食物，要不你帮我分析分析吧。</p>
<p>闪客：好的，现在我们做出如下改进。</p>
<p><strong>1. 按需创建Worker</strong>：刚初始化线程池时，不再立刻创建 corePoolSize 个工作线程，而是等待调用者不断提交任务的过程中，逐渐把工作线程 Worker 创建出来，等数量达到 corePoolSize 时就停止，把任务直接丢到队列里。那就必然要用一个属性记录已经创建出来的工作线程数量，就叫 <strong>workCount</strong> 吧。</p>
<p><strong>2. 加拒绝策略</strong>：实现上就是增加一个入参，类型是一个接口 <strong>RejectedExecutionHandler</strong>，由调用者决定实现类，以便在任务提交失败后执行 rejectedExecution 方法。</p>
<p><strong>3. 增加线程工厂</strong>：实现上就是增加一个入参，类型是一个接口 <strong>ThreadFactory</strong>，增加工作线程时不再直接 new 线程，而是调用这个由调用者传入的 ThreadFactory 实现类的 newThread 方法。</p>
<p>就像下面这样。</p>
<p><img src="/2021/04/28/thread%E8%AF%A6%E8%A7%A3/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>小宇：哇，还是你厉害，这一版应该很完美了吧？</p>
<p>闪客：不不不，离完美还差得很远，接下来的改进，由你来想吧，我这里可以给你一个提示</p>
<p><strong>弹性思维</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTjxNaj1t0BwIBXIG4UCkqlhmksHRa7gsqhdaQPGRx38bYW3noNZTTzQaf6FiciaKsRctR1HzJHficGw/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片"></p>
<h1 id="第五版"><a href="#第五版" class="headerlink" title="第五版"></a>第五版</h1><p>小宇：弹性思维？哈哈闪客你这术语说的真是越来越不像人话了</p>
<p>闪客：咳咳</p>
<p>小宇：哦，我是说你肯定是指我这个代码写的没有弹性，对吧？可是弹性是指什么呢？</p>
<p>闪客：简单说，在这个场景里，弹性就是在任务提交比较频繁，和任务提交非常不频繁这两种情况下，你这个代码是否有问题？</p>
<p>小宇：emmm 让我想想，我这个线程池，当提交任务的量突增时，工作线程和队列都被占满了，就只能走拒绝策略，其实就是被丢弃掉</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTjxNaj1t0BwIBXIG4UCkqlS3XAgEz0I4Ow6I8vAAbBfLS0Z1fqSX3AYG3SsleEOuExsKNhwPDgtg/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片"></p>
<p>闪客：是的</p>
<p>小宇：这样的确是太硬了，诶不过我想了下，调用方可以通过设置很大的核心线程数 corePoolSize 来解决这个问题呀。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTjxNaj1t0BwIBXIG4UCkqloDoAW4uFYpRRM23I6ZkdUM7Zvb4B9fjd3bv87YKYUQV4j6zAD4T5pg/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片"></p>
<p>闪客：的确是可以，但一般场景下 QPS 高峰期都很短，而为了这个很短暂的高峰，设置很大的核心线程数，简直太浪费资源了，你看上面的图不觉得眼晕么？</p>
<p>小宇：是呀，那怎么办呢，太大了也不行，太小了也不行。</p>
<p>闪客：我们可以发明一个新的属性，叫最大线程数 <strong>maximumPoolSize</strong>。当核心线程数和队列都满了时，新提交的任务仍然可以通过创建新的工作线程（叫它<strong>非核心线程</strong>），直到工作线程数达到 maximumPoolSize 为止，这样就可以缓解一时的高峰期了，而用户也不用设置过大的核心线程数。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXTjxNaj1t0BwIBXIG4UCkqlJkkYATwe2jZSIrKgCtWeOwMpk8nj6akQr2zw4DicVVsASicoRVOib480g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>小宇：哦好像有点感觉了，可是具体怎么操作呢？</p>
<p>闪客：想象力不行呀小宇，那你看下面的演示。</p>
<p><img src="/2021/04/28/thread%E8%AF%A6%E8%A7%A3/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>\1. 开始的时候和上一版一样，当 workCount &lt; corePoolSize 时，通过创建新的 Worker 来执行任务。</p>
<p>\2. 当 workCount &gt;= corePoolSize 就停止创建新线程，把任务直接丢到队列里。</p>
<p>\3. 但当队列已满且仍然 workCount &lt; maximumPoolSize 时，不再直接走拒绝策略，而是创建非核心线程，直到 workCount = maximumPoolSize，再走拒绝策略。</p>
<p>小宇：哎呀，我怎么没想到，这样 corePoolSize 就负责平时大多数情况所需要的工作线程数，而 maximumPoolSize 就负责在高峰期临时扩充工作线程数。</p>
<p>闪客：没错，高峰时期的弹性搞定了，那自然就还要考虑低谷时期。当长时间没有任务提交时，核心线程与非核心线程都一直空跑着，浪费资源。我们可以给<strong>非核心线程</strong>设定一个超时时间 <strong>keepAliveTime</strong>，当这么长时间没能从队列里获取任务时，就不再等了，销毁线程。</p>
<p><img src="/2021/04/28/thread%E8%AF%A6%E8%A7%A3/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>小宇：嗯，这回咱们的线程池在 QPS 高峰时可以临时扩容，QPS 低谷时又可以及时回收线程（非核心线程）而不至于浪费资源，真的显得十分 Q 弹呢。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTjxNaj1t0BwIBXIG4UCkqlhmksHRa7gsqhdaQPGRx38bYW3noNZTTzQaf6FiciaKsRctR1HzJHficGw/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片"></p>
<p>闪客：是呀是呀。诶不对，怎么又变成我说了，不是说这一版你来思考么？</p>
<p>小宇：我也想啊，但你这一讲技术就自说自话的毛病老是不改，我有啥办法。</p>
<p>闪客：额抱歉抱歉，那接下来你总结一下我们的线程池吧</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>小宇：嗯好的，首先它的构造方法是这个样子滴</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public FlashExecutor(</span><br><span class="line">        int corePoolSize,</span><br><span class="line">        int maximumPoolSize,</span><br><span class="line">        long keepAliveTime,</span><br><span class="line">        TimeUnit unit,</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">        ThreadFactory threadFactory,</span><br><span class="line">        RejectedExecutionHandler handler) </span><br><span class="line">&#123;</span><br><span class="line">    ... &#x2F;&#x2F; 省略一些参数校验</span><br><span class="line">    this.corePoolSize &#x3D; corePoolSize;</span><br><span class="line">    this.maximumPoolSize &#x3D; maximumPoolSize;</span><br><span class="line">    this.workQueue &#x3D; workQueue;</span><br><span class="line">    this.keepAliveTime &#x3D; unit.toNanos(keepAliveTime);</span><br><span class="line">    this.threadFactory &#x3D; threadFactory;</span><br><span class="line">    this.handler &#x3D; handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这些参数分别是</p>
<p><strong>int corePoolSize</strong>：核心线程数</p>
<p><strong>int maximumPoolSize</strong>：最大线程数</p>
<p><strong>long keepAliveTime</strong>：非核心线程的空闲时间</p>
<p><strong>TimeUnit unit</strong>：空闲时间的单位</p>
<p><strong>BlockingQueue<Runnable> workQueue</Runnable></strong>：任务队列（线程安全的阻塞队列）</p>
<p><strong>ThreadFactory threadFactory</strong>：线程工厂</p>
<p><strong>RejectedExecutionHandler handler</strong>：拒绝策略</p>
<p>整个任务的提交流程是</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXTjxNaj1t0BwIBXIG4UCkqlNOR6EbX3EVhyfp7fSy80IweianoAMNR6fHWicCpU9f9iaEickMyDls6BZQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>闪客：不错不错，这可是你自己总结的哟，现在还用我给你讲什么是线程池了么？</p>
<p>小宇：啊天呢，我才发现这似乎就是我一直弄不清楚的线程池的参数和原理呢！</p>
<p>闪客：没错，而且最后一版代码的构造方法，就是 Java 面试常考的 <strong>ThreadPoolExecutor</strong> 最长的那个构造方法，参数名都没变。</p>
<p>小宇：哇，太赞了！我都忘了一开始我想干嘛了，嘻嘻。</p>
<p>闪客：哈哈，不知不觉学到了技术才爽呢，对吧？晚饭时间快到了，要不要一块去吃山西面馆呀？</p>
<p>小宇：哦，那家店餐桌的颜色我不太喜欢，下次吧。</p>
<p>闪客：哦好吧。</p>
<blockquote>
<blockquote>
<p><strong>后记</strong> </p>
</blockquote>
</blockquote>
<p>线程池是面试常考的知识点，网上很多文章都是直接从它那有 7 个参数的构造方法讲起，强行把各个参数的含义说给你听，让人云里雾里。</p>
<p>希望读者读完本篇文章后，线程池的这些参数不再是死记硬背，而是像本文中这些动图一样在你的脑中活灵活现，这样就能永远记住他们啦~</p>
]]></content>
  </entry>
  <entry>
    <title>full gc</title>
    <url>/2021/05/10/full-gc/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>thread join</title>
    <url>/2021/05/10/thread-join/</url>
    <content><![CDATA[<blockquote>
<p>简单解释下，join就是调用wait()使线程进入WAIT状态。使线程完全执行完成。</p>
</blockquote>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Waits at most &#123;<span class="doctag">@code</span> millis&#125; milliseconds for this thread to</span></span><br><span class="line"><span class="comment"> * die. A timeout of &#123;<span class="doctag">@code</span> 0&#125; means to wait forever.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; This implementation uses a loop of &#123;<span class="doctag">@code</span> this.wait&#125; calls</span></span><br><span class="line"><span class="comment"> * conditioned on &#123;<span class="doctag">@code</span> this.isAlive&#125;. As a thread terminates the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> this.notifyAll&#125; method is invoked. It is recommended that</span></span><br><span class="line"><span class="comment"> * applications not use &#123;<span class="doctag">@code</span> wait&#125;, &#123;<span class="doctag">@code</span> notify&#125;, or</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> notifyAll&#125; on &#123;<span class="doctag">@code</span> Thread&#125; instances.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  millis</span></span><br><span class="line"><span class="comment"> *         the time to wait in milliseconds</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment"> *          if the value of &#123;<span class="doctag">@code</span> millis&#125; is negative</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  InterruptedException</span></span><br><span class="line"><span class="comment"> *          if any thread has interrupted the current thread. The</span></span><br><span class="line"><span class="comment"> *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span></span><br><span class="line"><span class="comment"> *          cleared when this exception is thrown.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="join使用时注意几点："><a href="#join使用时注意几点：" class="headerlink" title="join使用时注意几点："></a>join使用时注意几点：</h2><p><strong>1、join与start调用顺序问题</strong></p>
<p>　　上面的讨论大概知道了join的作用了，那么，入股 join在start前调用，会出现什么后果呢？先看下面的测试结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dxz.join;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"[BThread] Thread"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String threadName = Thread.currentThread().getName();</span><br><span class="line">        System.out.println(threadName + <span class="string">" start."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(threadName + <span class="string">" loop at "</span> + i);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(threadName + <span class="string">" end."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Exception from "</span> + threadName + <span class="string">".run"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String threadName = Thread.currentThread().getName();</span><br><span class="line">        System.out.println(threadName + <span class="string">" start."</span>);</span><br><span class="line">        BThread bt = <span class="keyword">new</span> BThread();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bt.join();</span><br><span class="line">            bt.start();</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Exception from main"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(threadName + <span class="string">" end!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">main start.</span><br><span class="line">[BThread] Thread start.</span><br><span class="line">[BThread] Thread loop at <span class="number">0</span></span><br><span class="line">[BThread] Thread loop at <span class="number">1</span></span><br><span class="line">main end!</span><br><span class="line">[BThread] Thread loop at <span class="number">2</span></span><br><span class="line">[BThread] Thread loop at <span class="number">3</span></span><br><span class="line">[BThread] Thread loop at <span class="number">4</span></span><br><span class="line">[BThread] Thread end.</span><br></pre></td></tr></table></figure>

<p>main线程没有等待[BThread]执行完再执行。join方法必须在线程start方法调用之后调用才有意义。这个也很容易理解：如果一个线程都没有start，那它也就无法同步了。</p>
<p><strong>2、join()与异常</strong></p>
<p>在join()过程中，如果当前线程被中断，则当前线程出现异常。(注意是调用thread.join()的线程被中断才会进入异常，比如a线程调用b.join()，a中断会报异常而b中断不会异常)</p>
<p>如下:threadB中启动threadA，并且调用其方法等待threadA完成，此时向threadB发出中断信号，会进入中断异常代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        String threadName = Thread.currentThread().getName();</span><br><span class="line">        System.out.println(threadName + <span class="string">" start."</span>);</span><br><span class="line">        BThread bt = <span class="keyword">new</span> BThread();</span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            bt.start();</span><br><span class="line">            bt.join();</span><br><span class="line">            </span><br><span class="line"><span class="comment">//        &#125; catch (Exception e) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println("Exception from main");</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        System.out.println(threadName + <span class="string">" end!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">main start.</span><br><span class="line">[BThread] Thread start.</span><br><span class="line">[BThread] Thread loop at <span class="number">0</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.InterruptedException</span><br><span class="line">    at java.lang.Object.wait(Native Method)</span><br><span class="line">    at java.lang.Thread.join(Thread.java:<span class="number">1249</span>)</span><br><span class="line">    at java.lang.Thread.join(Thread.java:<span class="number">1323</span>)</span><br><span class="line">    at com.dxz.join.TestDemo.main(TestDemo.java:<span class="number">46</span>)</span><br><span class="line">[BThread] Thread loop at <span class="number">1</span></span><br><span class="line">[BThread] Thread loop at <span class="number">2</span></span><br><span class="line">[BThread] Thread loop at <span class="number">3</span></span><br><span class="line">[BThread] Thread loop at <span class="number">4</span></span><br><span class="line">[BThread] Thread end.</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>thread</category>
      </categories>
      <tags>
        <tag>— thread</tag>
      </tags>
  </entry>
</search>
